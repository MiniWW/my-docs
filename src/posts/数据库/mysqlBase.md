---
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2024-05-05
category:
  - 数据库
tag:
  - 红
  - 圆
star: true
sticky: true
---

# 数据库基础

## 什么是元组, 码（键）, 候选码, 主码（主键）, 外码, 主属性, 非主属性？
- 元组:表（关系是一张表）中的一行数据
- 码（键）：可以唯一标识元组合的一个属性/多个属性组合
- 候选码：可能成为主码（键）的码，它可以唯一标识元组但最后不一定成为主码
- 主码：可以唯一标识元组的码，从候选码中选出来的，例如id
- 外码：是当前这张表中的一个属性，同时它关联另一张表的主码
- 主属性：构成主码的属性（如果主码有2个属性的话，主属性就有2个）
- 非主：一个元组的属性中，除了主属性之外的属性

## 什么是数据库范式（what）
数据库范式是一组规则，来约束数据库的表结构

### 为什么需要数据库范式（why）
减少数据冗余，节省存储空间
### 有哪些数据库范式，如何区分？（what）
- 第一范式（默认）：属性不可再分。基本关系数据库创建的每一张表都满足，
- 第二范式要求非主属性对任何候选键都是完全依赖的，不出现部分依赖的情况
> 考虑一个订单表，其中包含订单号、产品编号和产品描述。如果产品描述只依赖于产品编号而不依赖于订单号，
> 那么该表就不符合第二范式，因为产品描述只依赖于候选键的一部分。
> 为了符合第二范式，可以将产品描述与产品编号分离出来，
> 建立一个独立的产品表，使得产品描述完全依赖于产品编号.
![img.png](img.png)
- 第三范式：要求非主属性不能对候选码产生传递依赖，也就是说非主属性直接依赖于候选键，而不是依赖于其他非主属性
> 例如，在一个订单表中，除了订单号和产品编号之外还有客户姓名和客户地址。如果客户地址依赖于客户姓名而不是订单号，则存在传递依赖。
> 为了符合第三范式，应该将客户姓名和客户地址分离出来，建立一个独立的客户表，使得客户地址直接依赖于候选键（可能是客户编号），而不是依赖于客户姓名。

>比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。
> 该如何修改？(how)
>直接分解关系
> 
正确，根据您提供的关系R(学号, 姓名, 系名, 系主任)，存在非主属性系主任对于学号的传递函数依赖，因此不符合第三范式（3NF）的要求。
为了符合第三范式，需要对表的设计进行修改。

一种修改的方式是将关系R进行分解，以消除传递依赖。可以将关系R拆分为两个关系：

1. 学生关系（学号, 姓名, 系名）：这个关系包含了学生的学号、姓名以及所属系名。
2. 系信息关系（系名, 系主任）：这个关系包含了系名和该系的系主任。

这样，每个关系都符合第三范式的要求，不存在传递依赖。学生关系中，系名直接关联到系信息关系的系名，而不再通过系主任产生传递依赖。系信息关系中，系主任直接关联到系名，也不存在传递依赖。

修改后的关系如下：

1. 学生关系：

| 学号 | 姓名 | 系名  |
|------|------|-------|
| 1    | 张三 | 计算机系 |
| 2    | 李四 | 数学系  |
| 3    | 王五 | 物理系  |

2. 系信息关系：

| 系名   | 系主任 |
|--------|--------|
| 计算机系 | 王老师  |
| 数学系  | 张老师  |
| 物理系  | 李老师  |

通过这样的设计，每个关系都符合第三范式的要求，数据结构更加规范化，消除了冗余和传递依赖，提高了数据库的一致性和完整性。