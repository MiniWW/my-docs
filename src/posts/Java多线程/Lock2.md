---
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2024-05-05
category:
  - Java多线程
tag:
  - 红
  - 圆
star: true
sticky: true
---

# 3.JMM(java内存模型)
- 注意跟java内存结构区分
    - Java内存模型是什么（what）
## JMM是什么（what）
- JMM 定义了JVM将变量到内存中和从内存中读取变量的细节
- 也定义多线程访问共享变量的规则

## Java内存结构是什么？
  - 堆、栈、方法区、pc、本地方法栈

## JMM重要概念（what）

1. **主内存（Main Memory）**：
   主内存是所有线程共享的内存区域，包含了所有的共享变量。所有的变量都存储在主内存中，而线程的工作内存只包含了该线程独享的变量副本。

2. **工作内存（Working Memory）**：
   每个线程都有自己的工作内存，用于存储该线程使用到的变量副本或者共享变量的缓存副本。线程对变量的操作都是在工作内存中进行的，而不是直接在主内存中进行。

3. **内存屏障（Memory Barrier）**：
   内存屏障是一种同步机制，用于确保特定顺序的内存访问操作不会被重排序。在多线程并发场景下，内存屏障可以用来保证线程间的可见性和有序性。

4. **happens-before 关系**：
   happens-before 是 Java 内存模型中定义的一个偏序关系，用于规定变量在多线程环境下的可见性和顺序性。如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果对于第二个操作是可见的，并且第一个操作的执行顺序在第二个操作之前。

## JMM规则/特点（what）
1. 所有变量都必须存储在主内存中**（计算机的RAM)**
    >`这里说的变量是实例变量和类变量，不包括局部变量，**因为局部变量是线程私有的** '
      - 这是关于线程中变量的作用域和生命周期的概念。
      - 在多线程环境中，每个线程都有自己的栈空间，局部变量通常是在栈上分配的，因此每个线程拥有自己的一份局部变量副本，彼此之间互不影响。
2. 每一个线程都有自己的工作内存，里面存着用到的主内存变量的副本
   
3. 线程对变量的操作要在工作内存进行，不能操作主内存，也不能操作别的线程的工作内存
4. 线程之间的值传递要通过主内存实现

## happen-before原则和as-if-serial语义
- "happens-before" 原则保证了多线程之间操作的顺序关系和可见性，
- 而 "as-if-serial" 语义保证了多线程环境下程序的行为与单线程环境下的行为一致（只作用于但线程？）
> 让我用一个更具体的例子来说明这两个概念：

假设有两个线程 A 和 B，并且在线程 A 中有两个操作：

```java
x = 1;
y = 2;
```

在线程 B 中有一个操作：

```java
print(x + y);
```

现在，我们来分析一下 "happens-before" 原则和 "as-if-serial" 语义在这个例子中的作用：

1. **happens-before 原则**：
   - 假设操作 A 中的两个赋值语句是按顺序执行的，即先执行 `x = 1;`，然后执行 `y = 2;`。
   - 根据 "happens-before" 原则，如果操作 A 中的两个赋值语句 "happens-before" 线程 B 中的打印操作，那么在线程 B 中打印的结果将会是 3。这是因为线程 B 看到的是线程 A 中的结果，而且线程 A 的操作顺序不会被重排序到线程 B 的操作之后。

2. **as-if-serial 语义**：
   - 编译器和处理器可以对操作进行重排序，但必须保证程序的最终执行结果与按照程序顺序执行的结果一致。
   - 即使编译器和处理器对线程 A 中的操作进行了重排序，例如先执行 `y = 2;`，然后执行 `x = 1;`，但是由于 "as-if-serial" 语义，线程 B 中的打印操作仍然会看到线程 A 中操作的结果，即打印的结果也会是 3。

### 两者区别
   
   - **"happens-before" 原则**：是Java内存模型（JMM）中的概念，用于描述操作之间的偏序关系。在并发程序中，如果一个操作 "happens-before" 另一个操作，那么第一个操作的结果将对第二个操作可见，且第二个操作不会重排到第一个操作之前。
   - "happens-before" 原则强调的是操作之间的直接顺序关系，即先发生的操作对后发生的操作有影响。
   - 举例：在Java中，对一个变量的写操作 "happens-before" 后续对该变量的读操作，如果这两个操作位于不同的线程中，那么第一个线程对变量的写入结果将对第二个线程可见。

：
   - **"as-if-serial" 语义**是C++的一个概念，用于描述编译器和处理器优化的行为。根据这个语义，编译器和处理器可以对程序进行各种优化，只要这些优化不改变程序在单线程中的行为，即程序的执行结果与按照程序顺序执行时的结果相同。
   - "as-if-serial" 语义强调的是程序在单线程执行时的行为与多线程执行时的行为应该是一致的，即多线程执行不应该改变程序的语义。
   - 举例：如果在一个单线程程序中，语句A在语句B之前执行，那么根据 "as-if-serial" 语义，编译器和处理器可以对这两条语句进行优化，使得语句B在语句A之前执行，但程序的行为仍然与原始顺序执行时一致。

总的来说，"happens-before" 原则更关注并发程序中操作之间的顺序关系，而 "as-if-serial" 语义更关注编译器和处理器优化对程序行为的影响，但两者都旨在确保程序在多线程环境下的正确性。

## as-if-serial只作用于单线程吗？
- 总的来说，虽然 "as-if-serial" 语义主要针对单线程环境，
- 但在多线程环境下，它仍然可以作为编译器和处理器优化行为的一种指导原则，以确保程序的正确性

"happens-before" 原则是Java内存模型（Java Memory Model，JMM）中的概念，用于描述多线程程序中操作之间的偏序关系。这个原则指定了一组规则，用于确定一个操作是否可以被另一个操作所观察到，以及它们之间的时间顺序关系。这些规则有助于确保多线程程序的正确性和可预测性。

## "happens-before" 原则的主要规则：

1. **程序顺序规则（Program Order Rule）**：
   - 在一个线程中，按照程序的顺序，前一个操作的结果将对后续操作可见。

2. **监视器锁规则（Monitor Lock Rule）**：
   - 解锁一个监视器锁（通过 synchronized 或 Lock）的操作必须 "happens-before" 后续对这个监视器锁的加锁操作。

3. **volatile 变量规则（Volatile Variable Rule）**：
   - 对一个 volatile 变量的写操作必须 "happens-before" 后续对这个 volatile 变量的读操作。

4. **线程启动规则（Thread Start Rule）**：
   - 调用一个线程的 start() 方法必须 "happens-before" 这个线程的任何操作。

5. **线程终止规则（Thread Termination Rule）**：
   - 线程中的任何操作必须 "happens-before" 这个线程的终止。

6. **线程中断规则（Thread Interruption Rule）**：
   - 对线程调用 interrupt() 方法必须 "happens-before" 后续检查到该线程被中断的操作。

7. **对象终结规则（Finalizer Rule）**：
   - 一个对象的初始化必须 "happens-before" 该对象的 finalize() 方法被调用。

这些规则确保了在多线程环境中，操作的执行顺序和可见性，以及线程之间的交互都是可预测的，从而避免了一些常见的并发问题，如数据竞争、内存不一致等。