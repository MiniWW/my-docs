---
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2024-05-05
category:
  - Java多线程
tag:
  - 红
  - 圆
star: true
sticky: true
---
# 锁-一种同步机制

## 锁是什么
- 一种同步机制， 锁（lock）是一种同步机制，
- 用于控制对共享资源的访问，确保在任何时候只有一个线程可以访问该资源。
- 锁能够保证线程安全，防止多个线程同时访问共享资源时产生的数据不一致问题。
  **synchronized实现同步的基础：Java中的每一个对象都可以作为锁**
  - (why）因为每个对象都有一个monitor
    - 在Java中，任何对象都可以作为锁是因为Java中的锁实际上是通过对象的监视器（Monitor）来实现的。每个对象都有一个与之关联的监视器，这个监视器可以用来实现同步和互斥访问。因此，当我们使用`synchronized`关键字或`Lock`接口时，实际上是在操作对象的监视器，而不是对象本身。

   > 这种设计带来了一些优势：

   1. **灵活性**：因为任何对象都可以作为锁，所以可以根据具体的需求选择合适的对象作为锁，**而不需要额外创建特定的锁对象**。

   2. **封装性**：通过将同步操作封装在对象内部，**可以更好地实现数据的封装和保护**，同时简化了并发编程的复杂性。

  3. **自然性**：使用对象作为锁符合面向对象编程的思想，使得**同步机制与对象的状态和行为相关联**，更加自然和直观。

- 理清楚锁的对象到底是谁

## 锁的两套机制Synchornized和Lock接口

> Java中的并发编程主要通过两种方式来实现：使用关键字`synchronized`和使用`Lock`接口。

1. **synchronized**：
   - `synchronized` 是 Java 中的关键字，**不能被继承** 用于实现同步代码块或方法。
   - 当一个线程进入`synchronized`代码块或方法时，它会尝试获得对象的锁。如果锁已经被其他线程持有，该线程将被阻塞，直到锁被释放。
   - `synchronized` 关键字内置了锁的获取和释放机制，使得编程更加简单，但也可能导致性能问题，因为一旦一个线程持有了锁，其他线程就无法访问被锁定的代码块或方法。

2. **Lock接口**：
   - `Lock` 接口提供了更加灵活的锁定机制，相比于`synchronized`，它提供了更多的功能和控制。
   - `Lock` 接口的实现类包括 `ReentrantLock`、`ReentrantReadWriteLock`等。
   - 使用`Lock`接口可以实现更灵活的锁定机制，比如支持公平性，可中断性，尝试获取锁等待一段时间（避免死锁），以及支持多个条件变量等功能。
   - 与`synchronized`相比，`Lock`接口的主要优势在于提供了更多的控制和功能，但使用时需要注意锁的获取和释放，确保在适当的时候释放锁以避免死锁等问题。

## synchronized底层原理
`synchronized` 是 Java 中用于实现同步的关键字，它的底层原理涉及到对象头部标记、Monitor对象和指令原语等。

1. **对象头部标记**：
   - 在 Java 中，每个对象在内存中都有一个对象头部（Header）。
   - 对象头部包含了一些元数据，其中之一就是用于存储锁信息的部分。

2. **Monitor对象**：
   - 每个 Java 对象都与一个 Monitor 相关联，Monitor 是在对象头部标记的基础上实现的。
   - Monitor 是用来控制对象的锁定和解锁的，每个 Monitor 对象都与一个同步的代码块相关联。
   - 当一个线程进入 synchronized 代码块时，它会尝试获取这个代码块所关联的 Monitor 对象的锁。

3. **指令原语**：
   - Java 虚拟机中的字节码指令集包含了用于实现同步的指令原语，比如`monitorenter`和`monitorexit`。
   - 当一个线程进入 synchronized 代码块时，会执行`monitorenter`指令来尝试获取 Monitor 对象的锁。
   - 当线程退出 synchronized 代码块时，会执行`monitorexit`指令来释放 Monitor 对象的锁。

4. **锁升级与锁降级**：
   - Java 虚拟机会根据对象的访问情况和竞争情况自动进行锁升级和锁降级，以优化性能。
   - 在低竞争环境下，锁会逐渐升级为偏向锁，以减少同步的开销。
   - 在高竞争环境下，锁会逐渐升级为重量级锁，以保证多线程的安全性。

总的来说，`synchronized` 的底层原理涉及到对象头部标记、Monitor 对象和指令原语，在不同的并发场景下，Java 虚拟机会根据需要自动进行锁的升级和降级，以提供最佳的性能和线程安全性。



当理解 Java 并发编程时，需要掌握以下内容：

1. **线程基础**：线程是程序执行的基本单元，能够同时执行多个线程，每个线程有自己的执行路径。在 Java 中，线程是通过 java.lang.Thread 类表示的。

2. **创建线程**：可以通过以下方式创建线程：
    - 继承 Thread 类并重写 run() 方法。
    - 实现 Runnable 接口并将其传递给 Thread 类的构造函数。
    - 使用 Executor 框架创建线程池来管理线程的生命周期。

3. **线程状态**：线程可以处于以下状态之一：
    - 新建（New）：线程对象被创建但尚未调用 start() 方法时处于这种状态。
    - 运行（Runnable）：线程调用 start() 方法后，进入运行状态。
    - 阻塞（Blocked）：线程等待某个条件发生而暂停执行，比如等待输入/输出、获取锁。
    - 等待（Waiting）：线程等待其他线程显式唤醒。
    - 超时等待（Timed Waiting）：线程等待一段时间后自动恢复。
    - 终止（Terminated）：线程执行完毕或者出现异常而终止。

4. **线程同步**：确保多个线程安全地访问共享资源，可以使用以下方法之一：
    - 同步块：使用 synchronized 关键字保护关键代码段，确保在同一时间只有一个线程可以访问它。
    - 锁：使用 Lock 接口及其实现类，如 ReentrantLock。
    - 同步方法：将方法声明为 synchronized，确保在同一时间只有一个线程可以执行它。

5. **线程间通信**：线程间可以通过以下方式进行通信：
    - wait()、notify() 和 notifyAll() 方法用于在线程之间传递信号。
    - 使用 wait() 方法使线程进入等待状态，直到其他线程调用相同对象上的 notify() 或 notifyAll() 方法唤醒它们。
      当理解 Java 并发编程时，除了掌握线程基础、创建线程、线程状态、线程同步和线程间通信等内容外，还可以继续深入以下方面：

当涉及到Java并发编程时，了解清楚基本概念以及它们之间的关联非常重要。下面我会按照一个清晰的路线为你讲解：

### 1. 并发基础知识
- **并发与并行**：并发是指多个任务交替执行的能力，而并行是指多个任务同时执行。
- **线程与进程**：进程是程序的一个执行实例，线程是进程内的一个独立执行单元。
- **多线程编程**：Java通过`Thread`类和`Runnable`接口支持多线程编程。

### 2. 线程的生命周期
- **新建状态**：当线程对象被创建时。
- **就绪状态**：当线程准备好运行，但还未开始执行时。
- **运行状态**：线程执行`run()`方法时。
- **阻塞状态**：线程等待某个事件的发生，比如等待I/O完成。
- **死亡状态**：当线程执行完`run()`方法，或者由于异常退出时。

### 3. 线程安全性
- **共享资源**：多个线程同时访问的资源。
- **线程安全**：多个线程访问共享资源时不会产生不正确的结果。
- **线程不安全问题**：比如竞态条件、死锁等问题。
- **同步机制**：通过同步机制确保线程安全，比如使用`Synchronized`关键字或者`Lock`接口。

### 4. 同步工具
- **锁**：包括内置锁（`synchronized`关键字）、显示锁（`Lock`接口）等。
- **原子变量**：`Atomic`类提供了一系列原子操作，保证了线程安全。
- **信号量**：`Semaphore`类用于控制同时访问特定资源的线程数量。
- **倒计数器**：`CountDownLatch`类用于等待其他线程完成操作。

### 5. 并发集合
- **并发队列**：`ConcurrentLinkedQueue`等。
- **并发映射**：`ConcurrentHashMap`等。

### 6. 线程池
- **线程池概述**：用于管理和重用线程。
- **`Executor`框架**：`Executor`和`ExecutorService`接口用于管理线程。
- **`ThreadPoolExecutor`类**：用于创建自定义线程池。

### 7. Callable与Future
- **Callable接口**：类似于Runnable接口，但是可以返回结果或抛出异常。
- **Future接口**：表示异步计算的结果。

### 8. 并发编程模型
- **生产者-消费者模型**：通过一个共享的缓冲区实现生产者和消费者之间的通信。
- **读者-写者模型**：多个读者可以同时读取共享资源，但写者必须互斥地访问资源。

### 9. 并发工具类
- **`java.util.concurrent`包**：提供了一系列并发编程工具和数据结构。
- **`CyclicBarrier`**：让一组线程等待至某个状态之后再全部同时执行。
- **`Phaser`**：提供了更灵活的同步点。
- **`Exchanger`**：用于两个线程之间交换数据。

### 10. Java内存模型（JMM）
- **JMM概述**：定义了Java虚拟机如何与内存交互。
- **内存间的可见性**：保证一个线程修改了共享变量的值后，其他线程可以立即看到修改后的值。
- **happens-before规则**：一组规则用于指定操作之间的内存可见性关系。

了解并发编程的基础知识和相关概念，以及使用Java提供的工具和类库，可以帮助你编写高效、安全的多线程应用程序。
