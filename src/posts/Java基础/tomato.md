---
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2024-05-05
category:
  - Java基础
tag:
  - 红
  - 圆
star: true
sticky: true
---

# 2.Java基础

## 变量
### Java的8种基本类型和对应的的包装类型，以及他们的默认值（what）
1. byte ：Byte 0：初始化强制赋值(以下同理)
2. short：Short 0:
3. int：Integer 0：
4. float：Float 0f：
5. double：Double 0d:
6. long：Long 0L
7. char：Character 'u0000'
8. boolean：Boolean false:初始化强制赋值（null）

#### 为什么包装类型在main里要显式的初始化赋值？（why）
> 1.因为在main方法里他们是作为局部变量存在的，局部变量没有默认值，必须显式初始化
> 
> 2.作为类的字段时，他们是作为成员变量存在的，无论是基本数据类型还是包装类型，都有默认值
> 默认值都为空，int为0，boolean为false 包装类型的默认值为null
#### 包装类型的缓存机制你了解吗？（what）
> (when)当对Byte、Short、Integer、Character这四种类型进行自动装箱的时候，会触发到一个缓存机制
> （what)这个缓存机制指的是当用户创建一个【-128到127这个范围的整型或短字符的时候，会返回一个已经存在的对象引用，而不是重新创建一个对象
> （why)这是因为Java在编译的时候会对整型和短字符进行缓存，范围是-128到127的数值
> Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127]
> 范围的缓存数据，Boolean 直接返回 True or False。
> But
> 而不适用于显示的装箱（使用构造函数或者valueOf方法）。
#####  局部变量的成员变量的区别在哪（where）
1. 从语法格式来看：成员变量是属于类的，而局部变量是属于代码块或者方法的
    > 成员变量可以被public，private，以及static修饰，而局部变量不能被访问修饰符和static修饰
   > 但两者都可以被final修饰
2. 从生存周期来看:成员变量是属于对象的，随着对象的创建而存在，局部变量是属于则方法的，随着方法被调用而自动生成，随着方法结束而消亡
3. 从存储方式来看：成员变量如果是static修饰的，那么这个成员变量是属于类的，如果没用static修饰，那么这个成员变量是属于实例的；对象存在于堆内存中，局部变量存在于栈中
4. 从默认值来看：如果没有显示的赋值，成员变量有默认值（如果是包装类型，那么默认值是null，如果不是包装类似，就以对应的类型为准）局部变量没有自动默认值，必须显示赋值
    > 如果成员变量如果被final修饰，那么也必须显示赋值

`延伸：`
###### 为什么成员变量要有自动默认值？（why）
1. 成员变量默认自动的赋初始值的话，可以避免空引用的错误
2. 并且，对象的状态会更有可预测性

#####  显示赋值的方法（how？以Boolean为例）
1. **使用`Boolean`的静态工厂方法`valueOf`**：`Boolean`类提供了一个静态工厂方法`valueOf`，它接受一个`boolean`值或者一个`String`值（`"true"`或`"false"`）作为参数，并返回对应的`Boolean`对象。示例如下：

    ```java
    Boolean bool1 = Boolean.valueOf(true); // 传入布尔值 true
    Boolean bool2 = Boolean.valueOf("true"); // 传入字符串 "true"
    ```

2. **使用自动装箱**：Java提供了自动装箱（autoboxing）的功能，可以自动将基本数据类型转换为对应的包装类型。因此，你可以直接将`boolean`值赋给`Boolean`对象，系统会自动进行装箱操作。示例如下：

    ```java
    Boolean bool3 = true; // 自动装箱，将布尔值 true 赋给 Boolean 对象
    ```
> Boolean 在java9之后没有无参构造方法

##### final是什么（what）
##### 访问修饰符是什么？(what)
> 访问修饰符有pubilc protected privete default（包级别） 

#### 为什么Java更经常用包装类型而不是基本的数据类型？（why）
>1. 首先这样能更好的利用java语言面向对象的特性，使用包装类型能让基本的数据类型也能像对象一样被使用，例如调用方法，传递给方法
>2. 第二个，在空值方面，基本数据类型没有null，但包装类型有，这样可以很好的表示一个值可能缺失或者未知的情况（例如开发中大量的DTO)
>3. 第三个，泛型只能用于对象，在使用集合类的时候，需要包装类型，不能用基本的数据类型
>4. 第4个，在java的框架设计上面，java的很多标准库和框架通常使用包装类型，这种偏好也比较影响了我们的开发习惯
>5. 第5个，java提供的自动装箱和自动拆箱，使得基本类型在包装类型之间的转换更方便

#### 静态变量是什么（what）
> 静态变量是被static修饰的变量，它属于类的，是类的属性，该类的所有对象共享，可以通过类名来访问

## 方法
### 方法的类型有哪些（what）
> 静态方法和实例方法（what)和区别，
> 1. 静态方法是属于类的，通过类名访问，静态方法不能调用非静态成员
> 2. 实例方法是属于对象的，必须通过对象调用
 
>静态方法只能用类名访问吗，不能用对象访问吗（why)
> 推荐用类名，以清晰地表达其与类的关系。：可以用对象，但这样做通常被视为不推荐的做法，
> 因为静态属性是与类相关联的而不是与类的特定实例相关联的。

> 为什么静态方法不能调用非静态成员（why)
> 1. 因为静态方法在类加载的时候就被分配内存了，在对象被创建之前就可以被调用，非静态成员是属于对象的。静态方法存在的时候非实例成员还不存在
> 





