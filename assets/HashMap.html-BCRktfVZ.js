import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,f as i}from"./app-D8tK2wE0.js";const n="/my-docs/assets/img-DtYey0nw.png",s="/my-docs/assets/img_1-BPLmrL-_.png",o="/my-docs/assets/img_3-CYwofMjX.png",p="/my-docs/assets/img_4-CGuikixi.png",l="/my-docs/assets/img_5-NIu0zd8J.png",r="/my-docs/assets/img_6-8ZXPq6dl.png",g={},c=i('<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h1><blockquote><p>图源网络：</p></blockquote><figure><img src="'+n+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><h2 id="hashmap的put方法的具体流程" tabindex="-1"><a class="header-anchor" href="#hashmap的put方法的具体流程"><span>HashMap的put方法的具体流程</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><ol><li><p>判断键值对<strong>数组table是否为空或为null</strong>，否则执行<strong>resize()进行扩容（初始化）</strong></p></li><li><p>根据键值key的hash值计算得到数组索引i</p></li><li><p>判断table[i]==null，条件成立，<strong>直接新建节点添加</strong></p></li><li><p>如果table[i]==null ,不成立</p><blockquote><p>4.1 判断table[i]（当前位置）的key一样，<strong>如果相同直接覆盖value</strong></p><p>4.2 <strong>如果不同</strong>：判断table[i] （当前这个桶存储了一个红黑树的头结点）是否为treeNode，即table[i] 是否是红黑树，<strong>如果是红黑树，则直接在树中插入键值对</strong></p><p>4.3 <strong>如果不是红黑树，那就是链表，遍历table[i]记录的链表，准备在链表的尾部插入数据</strong>，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，遍历过程中若发现key已经存在直接覆盖value</p></blockquote></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了<strong>最大容量threshold（数组长度*0.75）</strong>，如果超过，进行扩容。</p></li></ol></div><figure><img src="'+s+'" alt="img_1.png" tabindex="0" loading="lazy"><figcaption>img_1.png</figcaption></figure><h2 id="hashmap扩容" tabindex="-1"><a class="header-anchor" href="#hashmap扩容"><span>HashMap扩容</span></a></h2><blockquote><p><strong>ps：什么时候需要HashMap的扩容？</strong></p><p>首次添加元素的时候以及容量到达阈值的时候 <img src="'+o+'" alt="img_3.png" loading="lazy"></p></blockquote><blockquote><ul><li>在<strong>添加元素或初始化的时候需要调用resize方法进行扩容</strong>，<strong>第一次添加数据初始化数组长度为16</strong>，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</li><li>每次扩容的时候，<strong>都是扩容之前容量的2倍；</strong></li><li>扩容之后，会新创建一个数组，<strong>需要把老数组中的数据挪动到新的数组中</strong></li><li>没有hash冲突的节点，则直接使用 <strong>e.hash &amp; (newCap - 1) 计算新数组的索引位置</strong>（对数组的新长度取模）</li><li>如果是红黑树，走红黑树的添加（也是遍历红黑树的每个节点，重新计算每个节点的位置）</li><li>如果是链表，则需要遍历链表（的每个节点），判断(e.hash &amp; oldCap)是否为0，如果为0，该元素停留在原始位置，如果不为0，移动到<strong>原始位置+旧容量</strong>这个位置上</li><li><strong>（也就是：一部分节点的索引不变，另一部分索引为“原索引+旧容量”）</strong></li><li>节点迁移示意图：<strong>可以看到同一条链表里的元素不一定会全部都在新数组同一个“桶”里</strong>，红黑树也是如此，所以可能红黑树</li><li>会出现被拆分的情况，如果红黑树的树节点小于6，那么就会退化成一个链表</li><li><img src="'+p+'" alt="img_4.png" tabindex="0" loading="lazy"><figcaption>img_4.png</figcaption></li></ul></blockquote><p>扩容的流程：</p><p><img src="'+l+'" alt="img_5.png" loading="lazy"><img src="'+r+'" alt="img_6.png" loading="lazy"></p>',11),m=[c];function h(u,d){return e(),a("div",null,m)}const y=t(g,[["render",h],["__file","HashMap.html.vue"]]),f=JSON.parse('{"path":"/posts/Java%E9%9B%86%E5%90%88/HashMap.html","title":"HashMap","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-05-09T00:00:00.000Z","category":["Java集合"],"tag":["红","圆"],"star":true,"sticky":true,"description":"HashMap 图源网络： img.pngimg.png HashMap的put方法的具体流程 提示 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化） 根据键值key的hash值计算得到数组索引i 判断table[i]==null，条件成立，直接新建节点添加 如果table[i]==null ,不成立 4.1 判...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/posts/Java%E9%9B%86%E5%90%88/HashMap.html"}],["meta",{"property":"og:site_name","content":"主页"}],["meta",{"property":"og:title","content":"HashMap"}],["meta",{"property":"og:description","content":"HashMap 图源网络： img.pngimg.png HashMap的put方法的具体流程 提示 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化） 根据键值key的hash值计算得到数组索引i 判断table[i]==null，条件成立，直接新建节点添加 如果table[i]==null ,不成立 4.1 判..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-16T08:47:02.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"HashMap"}],["meta",{"property":"article:author","content":"MiniW"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:tag","content":"圆"}],["meta",{"property":"article:published_time","content":"2024-05-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-16T08:47:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap\\",\\"image\\":[\\"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg\\"],\\"datePublished\\":\\"2024-05-09T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-16T08:47:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MiniW\\"}]}"]]},"headers":[{"level":2,"title":"HashMap的put方法的具体流程","slug":"hashmap的put方法的具体流程","link":"#hashmap的put方法的具体流程","children":[]},{"level":2,"title":"HashMap扩容","slug":"hashmap扩容","link":"#hashmap扩容","children":[]}],"git":{"createdTime":1715213724000,"updatedTime":1726476422000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":9}]},"readingTime":{"minutes":2.36,"words":707},"filePathRelative":"posts/Java集合/HashMap.md","localizedDate":"2024年5月9日","excerpt":"\\n<blockquote>\\n<p>图源网络：</p>\\n</blockquote>\\n<figure><figcaption>img.png</figcaption></figure>\\n<h2>HashMap的put方法的具体流程</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<ol>\\n<li>\\n<p>判断键值对<strong>数组table是否为空或为null</strong>，否则执行<strong>resize()进行扩容（初始化）</strong></p>\\n</li>\\n<li>\\n<p>根据键值key的hash值计算得到数组索引i</p>\\n</li>\\n<li>\\n<p>判断table[i]==null，条件成立，<strong>直接新建节点添加</strong></p>\\n</li>\\n<li>\\n<p>如果table[i]==null ,不成立</p>\\n<blockquote>\\n<p>4.1 判断table[i]（当前位置）的key一样，<strong>如果相同直接覆盖value</strong></p>\\n<p>4.2 <strong>如果不同</strong>：判断table[i] （当前这个桶存储了一个红黑树的头结点）是否为treeNode，即table[i] 是否是红黑树，<strong>如果是红黑树，则直接在树中插入键值对</strong></p>\\n<p>4.3 <strong>如果不是红黑树，那就是链表，遍历table[i]记录的链表，准备在链表的尾部插入数据</strong>，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，遍历过程中若发现key已经存在直接覆盖value</p>\\n</blockquote>\\n</li>\\n<li>\\n<p>插入成功后，判断实际存在的键值对数量size是否超多了<strong>最大容量threshold（数组长度*0.75）</strong>，如果超过，进行扩容。</p>\\n</li>\\n</ol>\\n</div>","autoDesc":true}');export{y as comp,f as data};
