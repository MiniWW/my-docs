import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as o,f as a}from"./app-CVl1bgfN.js";const i="/my-docs/assets/img_3-3SLWE2OO.png",n="/my-docs/assets/img_4-DqNs6kWp.png",l={},s=a('<h1 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h1><h2 id="面向对象和面向过程的区别是什么-what" tabindex="-1"><a class="header-anchor" href="#面向对象和面向过程的区别是什么-what"><span>面向对象和面向过程的区别是什么？（what)</span></a></h2><blockquote><p>面向过程是解决问题的过程拆分成一个个解决方法来执行，面向对象是抽象出对象，让对象去执行相关的方法来解决问题</p></blockquote><ul><li>面向对象和面向过程的性能哪个高？ <ul><li>这个没有绝对之分，得看情况而定</li></ul></li></ul><h3 id="什么是面向对象的三大特性" tabindex="-1"><a class="header-anchor" href="#什么是面向对象的三大特性"><span>什么是面向对象的三大特性？：</span></a></h3><ol><li><p>封装：将数据（也就是属性或者说成员变量）和操作这些数据的方法封装在一个对象内部</p></li><li><p>继承：继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，建立类之间的层次关系。 同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p></li><li><p>多态：同一方法在不同的对象上有不同的行为，通过方法重写（覆盖）/重载来实现（how）</p></li><li><h4 id="多态解决了什么问题" tabindex="-1"><a class="header-anchor" href="#多态解决了什么问题"><span>多态解决了什么问题？</span></a></h4></li></ol><p>多态的目的是为了提高代码的灵活性和可扩展性，允许在程序在运行时再确定调用的是子类还是父类的方法。</p><h3 id="对象实体和对象引用的区别是什么-what" tabindex="-1"><a class="header-anchor" href="#对象实体和对象引用的区别是什么-what"><span>对象实体和对象引用的区别是什么（what)</span></a></h3><ol><li>对象实体是实际存在于堆内存的对象，对象引用是指向实体对象的指针，或者说引用、别名，对象引用存在于栈内存中</li><li>对象实体存在于堆内存中，对象引用存在于栈内存中</li><li>一个对象引用只能指向一个对象实体，一个对象实体有多个对象引用</li></ol><h4 id="对象相等和引用相等的区别是什么-what" tabindex="-1"><a class="header-anchor" href="#对象相等和引用相等的区别是什么-what"><span>对象相等和引用相等的区别是什么（what)</span></a></h4><ul><li>对象相等是内存中的内容是否相等</li><li>引用相等是引用的地址是否相等</li></ul><h2 id="接口和抽象类的共同点和区别-what" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的共同点和区别-what"><span>接口和抽象类的共同点和区别(what)</span></a></h2><h4 id="共同" tabindex="-1"><a class="header-anchor" href="#共同"><span>共同</span></a></h4><ul><li>抽象类和接口都不能被实例化</li></ul><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h4><blockquote><p><strong>设计目的</strong></p></blockquote><ul><li><strong>接口</strong>：用于定义一组没有实现的方法，规定实现这些接口的类必须实现这些方法。<strong>接口更多地强调的是行为的规范</strong>。一个类可以实现多个接口，从而组合多种行为。</li><li><strong>抽象类</strong>：用于定义一个类的基本结构，包括一些已实现的方法和一些未实现的抽象方法。抽象类作为其他类的基类，允许提供部分实现，并允许子类重写或实现特定方法。</li></ul><blockquote><p><strong>方法的实现</strong></p></blockquote><ul><li><strong>接口</strong>：接口中的方法默认是抽象的，<strong>不能有方法的实现</strong>（Java 8开始接口可以有<code>default</code>方法和<code>static</code>方法，这些方法可以有实现，但仍然无法存储状态）。</li><li><strong>抽象类</strong>：抽象类可以包含<strong>抽象方法</strong>（没有方法体）和<strong>非抽象方法</strong>（有实现）。它可以在某些情况下提供部分实现，让子类继承和使用。（但是**“抽象类必须包含抽象方法”**这句话是错的!)</li></ul><blockquote><p><strong>成员变量</strong></p></blockquote><ul><li><strong>接口</strong>：接口中只能有<code>public static final</code>类型的常量，不能包含其他类型的成员变量（也就是所有的字段都是常量，且<strong>隐式</strong>是<code>public static final</code>）。</li><li><strong>抽象类</strong>：抽象类可以包含普通的成员变量，并且这些变量可以有各种访问修饰符（<code>private</code>，<code>protected</code>，<code>public</code>等），抽象类允许存储实例状态。<strong>（抽象方法的默认访问权限是</strong> <code>default</code>（包私有），而不是 <code>public</code>）</li></ul><blockquote><p><strong>构造方法</strong></p></blockquote><ul><li><strong>接口</strong>：接口<strong>没有构造方法</strong>，因为接口不能被实例化。</li><li><strong>抽象类</strong>：抽象类可以有构造方法，尽管抽象类本身不能被实例化，但它的子类可以调用其构造方法。</li></ul><blockquote><p><strong>多重继承</strong></p></blockquote><ul><li><strong>接口</strong>：Java允许一个类实现多个接口，这相当于Java支持了一种有限的多重继承（通过行为的组合）。</li><li><strong>抽象类</strong>：一个类只能继承一个抽象类（单继承限制），因为Java不支持多继承。</li></ul><blockquote><p><strong>访问修饰符</strong></p></blockquote><ul><li><strong>接口</strong>：接口中定义的所有方法默认是<code>public</code>，不能使用其他修饰符。</li><li><strong>抽象类</strong>：抽象类中可以定义带有各种访问修饰符（<code>private</code>, <code>protected</code>, <code>public</code>）的方法和变量。</li></ul><h2 id="拷贝" tabindex="-1"><a class="header-anchor" href="#拷贝"><span>拷贝</span></a></h2><h3 id="深拷贝和浅拷贝、引用拷贝是什么-what" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝、引用拷贝是什么-what"><span>深拷贝和浅拷贝、引用拷贝是什么（what）(*)</span></a></h3><blockquote><p>深拷贝和齐纳拷贝都新建了一个对象，引用不会新建一个对象</p><p>首先浅拷贝和深拷贝都会新建一个对象，但是引用拷贝不会创建一个新的对象，只是创建了一个指向原始对象的引用</p><p>浅拷贝的新对象和原始对象内容相同，但是原始对象的子对象，浅拷贝只是复制了一份引用，而不是把子对象也复制一份</p><p>深拷贝就会递归的也复制子对象，复制得更彻底</p></blockquote><ul><li><strong>浅拷贝会创建一个对象</strong>，新对象的内容与原始对象相同，不过对于原始对象的子对象，浅拷贝只是复制了一份引用，而不是把子对象也复制了一份</li><li><strong>深拷贝会创建一个对象</strong>，并且递归复制原始对象的子对象</li><li><strong>引用拷贝不会创建一个对象</strong>只是创建了一个指向原始对象的新引用</li><li><img src="'+i+'" alt="img_3.png" tabindex="0" loading="lazy"><figcaption>img_3.png</figcaption></li><li><img src="'+n+'" alt="img_4.png" tabindex="0" loading="lazy"><figcaption>img_4.png</figcaption></li></ul>',31),r=[s];function c(p,h){return e(),o("div",null,r)}const u=t(l,[["render",c],["__file","OOPBase.html.vue"]]),m=JSON.parse('{"path":"/posts/Java/OOPBase.html","title":"面向对象","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-05-05T00:00:00.000Z","category":["Java基础"],"tag":["红","圆"],"star":true,"sticky":true,"description":"面向对象 面向对象和面向过程的区别是什么？（what) 面向过程是解决问题的过程拆分成一个个解决方法来执行，面向对象是抽象出对象，让对象去执行相关的方法来解决问题 面向对象和面向过程的性能哪个高？ 这个没有绝对之分，得看情况而定 什么是面向对象的三大特性？： 封装：将数据（也就是属性或者说成员变量）和操作这些数据的方法封装在一个对象内部 继承：继承允许...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/posts/Java/OOPBase.html"}],["meta",{"property":"og:site_name","content":"主页"}],["meta",{"property":"og:title","content":"面向对象"}],["meta",{"property":"og:description","content":"面向对象 面向对象和面向过程的区别是什么？（what) 面向过程是解决问题的过程拆分成一个个解决方法来执行，面向对象是抽象出对象，让对象去执行相关的方法来解决问题 面向对象和面向过程的性能哪个高？ 这个没有绝对之分，得看情况而定 什么是面向对象的三大特性？： 封装：将数据（也就是属性或者说成员变量）和操作这些数据的方法封装在一个对象内部 继承：继承允许..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-16T06:40:56.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"面向对象"}],["meta",{"property":"article:author","content":"MiniW"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:tag","content":"圆"}],["meta",{"property":"article:published_time","content":"2024-05-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-16T06:40:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象\\",\\"image\\":[\\"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg\\"],\\"datePublished\\":\\"2024-05-05T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-16T06:40:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MiniW\\"}]}"]]},"headers":[{"level":2,"title":"面向对象和面向过程的区别是什么？（what)","slug":"面向对象和面向过程的区别是什么-what","link":"#面向对象和面向过程的区别是什么-what","children":[{"level":3,"title":"什么是面向对象的三大特性？：","slug":"什么是面向对象的三大特性","link":"#什么是面向对象的三大特性","children":[]},{"level":3,"title":"对象实体和对象引用的区别是什么（what)","slug":"对象实体和对象引用的区别是什么-what","link":"#对象实体和对象引用的区别是什么-what","children":[]}]},{"level":2,"title":"接口和抽象类的共同点和区别(what)","slug":"接口和抽象类的共同点和区别-what","link":"#接口和抽象类的共同点和区别-what","children":[]},{"level":2,"title":"拷贝","slug":"拷贝","link":"#拷贝","children":[{"level":3,"title":"深拷贝和浅拷贝、引用拷贝是什么（what）(*)","slug":"深拷贝和浅拷贝、引用拷贝是什么-what","link":"#深拷贝和浅拷贝、引用拷贝是什么-what","children":[]}]}],"git":{"createdTime":1726466978000,"updatedTime":1726468856000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":4.66,"words":1397},"filePathRelative":"posts/Java/OOPBase.md","localizedDate":"2024年5月5日","excerpt":"\\n<h2>面向对象和面向过程的区别是什么？（what)</h2>\\n<blockquote>\\n<p>面向过程是解决问题的过程拆分成一个个解决方法来执行，面向对象是抽象出对象，让对象去执行相关的方法来解决问题</p>\\n</blockquote>\\n<ul>\\n<li>面向对象和面向过程的性能哪个高？\\n<ul>\\n<li>这个没有绝对之分，得看情况而定</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>什么是面向对象的三大特性？：</h3>\\n<ol>\\n<li>\\n<p>封装：将数据（也就是属性或者说成员变量）和操作这些数据的方法封装在一个对象内部</p>\\n</li>\\n<li>\\n<p>继承：继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，建立类之间的层次关系。\\n同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p>\\n</li>\\n<li>\\n<p>多态：同一方法在不同的对象上有不同的行为，通过方法重写（覆盖）/重载来实现（how）</p>\\n</li>\\n<li>\\n<h4>多态解决了什么问题？</h4>\\n</li>\\n</ol>","autoDesc":true}');export{u as comp,m as data};
