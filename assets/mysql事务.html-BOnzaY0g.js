import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,f as l}from"./app-B5wQ218V.js";const e="/my-docs/assets/img_1-CtZGzErg.png",t={},o=l(`<h1 id="待定名称" tabindex="-1"><a class="header-anchor" href="#待定名称"><span>待定名称</span></a></h1><h2 id="mysql的基础架构-一条sql语句在mysql中的执行流程" tabindex="-1"><a class="header-anchor" href="#mysql的基础架构-一条sql语句在mysql中的执行流程"><span>mysql的基础架构（一条sql语句在mysql中的执行流程）</span></a></h2><p>假设我们有一个简单的表结构如下：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> students <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">INT</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们要执行一个简单的查询语句，查找年龄小于 25 岁的学生：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> students <span class="token keyword">WHERE</span> age <span class="token operator">&lt;</span> <span class="token number">25</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个查询语句在 MySQL 中的执行流程可以描述如下：</p><ol><li><p><strong>SQL 解析</strong>：</p><ul><li>MySQL 首先对 SELECT 语句进行解析，确定查询的语法和语义。</li></ul></li><li><p><strong>权限验证</strong>：</p><ul><li>MySQL 检查当前用户是否具有对 <code>students</code> 表的查询权限。</li></ul></li><li><p><strong>执行计划生成</strong>：</p><ul><li>MySQL 根据查询条件 <code>age &lt; 25</code> 生成执行计划，可能选择使用 <code>age</code> 列上的索引进行扫描。</li></ul></li><li><p><strong>查询优化器</strong>：</p><ul><li>查询优化器可能会根据 <code>age</code> 列的统计信息和索引信息，决定使用索引扫描或者表扫描来获取数据。</li></ul></li><li><p><strong>执行计划执行</strong>：</p><ul><li>MySQL 根据执行计划执行查询操作，可能会进行索引扫描或者表扫描，获取符合条件的数据行。</li></ul></li><li><p><strong>结果返回</strong>：</p><ul><li>MySQL 将查询结果返回给客户端，包括符合条件的学生记录。</li></ul></li></ol><p>通过这个简单的例子，可以清楚地了解一个查询语句在 MySQL 中的执行流程。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><p>在 MySQL 中，一个 SQL 语句的执行流程通常可以分为以下几个步骤：</p><ol><li><p><strong>经过连接器-权限验证</strong>：</p><ul><li>在执行 SQL 语句之前，MySQL 会对当前用户的权限进行验证，确保当前用户对所操作的数据库和表具有足够的权限。如果用户权限不足，将会拒绝执行该 SQL 语句。</li></ul></li><li><p><strong>分析器-SQL 解析</strong>：</p><ul><li>MySQL 首先对 SQL 语句进行解析，分析 SQL 语法，确定 SQL 语句的语义和操作类型。解析器会检查 SQL 语句的语法是否正确，并生成相应的内部数据结构，用于后续的执行计划生成和优化。</li></ul></li><li><p><strong>执行器-执行计划生成</strong>：</p><ul><li>接下来，MySQL 会根据 SQL 语句的操作类型（查询、插入、更新、删除等）生成执行计划。执行计划包括了 MySQL 如何获取和处理数据的详细步骤，比如选择使用哪个索引、是否进行表扫描等。</li></ul></li><li><p><strong>优化器-查询优化器</strong>：</p><ul><li>MySQL 的查询优化器会对生成的执行计划进行优化，以提高 SQL 语句的执行效率。优化器会根据表的统计信息、索引信息等来选择最优的执行路径，以减少查询的成本和响应时间。</li></ul></li><li><p><strong>执行器-操作引擎-执行计划执行</strong>：</p><ul><li>最后，MySQL 根据生成的执行计划开始执行 SQL 语句。根据执行计划的指示，MySQL 可能会进行索引扫描、表扫描、排序、聚合等操作，最终得到 SQL 语句的结果集。</li></ul></li><li><p><strong>结果返回</strong>：</p><ul><li>当 SQL 语句执行完成后，MySQL 将结果返回给客户端。对于查询语句，返回的是查询结果集；对于更新语句，返回的是受影响的行数；对于插入语句，返回的是新插入数据的标识等。</li></ul></li></ol><p><img src="`+e+`" alt="img_1.png" loading="lazy"> 这就是一个 SQL 语句在 MySQL 中的基本执行流程。在执行过程中，MySQL 会根据实际情况动态调整执行计划，并根据硬件资源和数据库状态来进行优化和调整，以提高 SQL 语句的执行效率。</p><h2 id="mysql有哪两个存储引擎-都有事务吗-what" tabindex="-1"><a class="header-anchor" href="#mysql有哪两个存储引擎-都有事务吗-what"><span>mysql有哪两个存储引擎？都有事务吗（what）</span></a></h2><ul><li>mysql常用的存储引擎有InnoDB（默认）和myISAM(还有别的)</li><li>MYISAM存储殷勤不支持行级锁、事务、MVCC机制，InnoDB支持</li></ul><h2 id="单个mysql事务" tabindex="-1"><a class="header-anchor" href="#单个mysql事务"><span>单个mysql事务</span></a></h2><h3 id="什么是事务-what" tabindex="-1"><a class="header-anchor" href="#什么是事务-what"><span>什么是事务（what）</span></a></h3><ul><li>事务是把一个或多个操作作为一个整体的操作，里面的事务要么全部成功，要么全部失败</li></ul><h3 id="事务特性acid" tabindex="-1"><a class="header-anchor" href="#事务特性acid"><span>事务特性ACID</span></a></h3><ul><li>A:原子性</li><li>C：一致性</li><li>I：隔离性</li><li>D：持久性</li><li>AID是为了C 分别代表什么意思？ <blockquote><p>举个例子： A要向B转账100： A的账户要减少100，B的账户要增加100</p><ol><li>这两个操作要么都成功，要么都失败：原子性</li><li>一致性则是，事务在执行前后数据库应该保持一致性状态,A的账户减100，B的账户必须要增加一百，前后的总额没有变</li><li>隔离性：当前这个事务不能受其他事务的干扰</li><li>持久性：事务一旦提交，其结果应该是永久性的，即使系统崩溃或发生故障，数据也不应该丢失</li></ol></blockquote></li></ul><h3 id="靠什么来保证mysql的特性的-how" tabindex="-1"><a class="header-anchor" href="#靠什么来保证mysql的特性的-how"><span>靠什么来保证mysql的特性的？（how）</span></a></h3><ul><li><code>redo log</code>保证了事务的持久性，</li><li><code>undo log</code>保证了事务的原子性和一致性</li></ul><h3 id="延伸-redolog和undo-log是什么-what" tabindex="-1"><a class="header-anchor" href="#延伸-redolog和undo-log是什么-what"><span>延伸：redoLog和undo log是什么（what）</span></a></h3><ol><li><p><strong>Redo Log（重做日志）</strong>：</p><ul><li>redo log 记录了对数据库进行的所有更改操作。</li><li>当事务提交时，其所做的修改首先被写入 redo log 中</li></ul><blockquote><p>redo log 的作用在于，当系统发生故障导致数据库的内存中的修改<strong>未被写入磁盘时</strong>， 可以通过 redo log 中的信息来<strong>重新应用这些修改</strong>，从而保证了事务的持久性。</p><ul><li>(why can?）<strong>因为即使在发生故障后，redo log 仍然存在</strong>，并且会按顺序写入磁盘，所以可以确保这些修改最终被持久化到磁盘上。</li></ul></blockquote></li><li><p><strong>Undo Log（撤销日志）</strong>：</p><ul><li>undo log 记录了事务所做的修改的反向操作，也就是事务的撤销信息。</li><li>当事务执行过程中需要回滚时，可以利用 undo log 中的信息将事务的修改操作撤销，从而恢复到事务开始前的状态。</li></ul><blockquote><p>undo log 的作用在于，当事务执行过程中发生了错误或需要回滚时，可以使用 undo log 来撤销事务的部分或全部修改，保证了事务的原子性和一致性。</p><ul><li>(why can?)因为 undo log 记录了事务的撤销信息，所以即使事务执行过程中发生了错误，也可以使用 undo log 来回滚事务，从而保证数据库的一致性。</li></ul></blockquote></li></ol><h3 id="redo-log和undo-log举个例子" tabindex="-1"><a class="header-anchor" href="#redo-log和undo-log举个例子"><span>redo log和undo log举个例子：</span></a></h3><p>假设我们有一个银行账户表格，其中包含两个账户：账户A和账户B。现在，我们想要从账户A向账户B转账100元。以下是一个简单的示例：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">-- 开启事务</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>

<span class="token comment">-- 扣除账户A中的100元</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> account_number <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 将100元存入账户B中</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> account_number <span class="token operator">=</span> <span class="token string">&#39;B&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 提交事务</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们首先执行了一个 SQL 事务，其中包含两个更新操作：一个是从账户A扣除100元，另一个是向账户B增加100元。接下来，让我们看看 Redo log 和 Undo log 是如何应用于这个示例的：</p><ol><li><p><strong>Redo log 的应用</strong>：</p><ul><li>当我们执行以上 SQL 事务时，数据库系统会记录这些更改的重做信息到 Redo log 中。这些信息包括了对账户A和账户B的更新操作，以及相应的重做操作。</li><li>例如，Redo log 中可能记录了对账户A余额减少100元和对账户B余额增加100元的重做操作。</li></ul></li><li><p><strong>Undo log 的应用</strong>：</p><ul><li>同时，数据库系统也会记录这个事务的撤销信息到 Undo log 中。这些信息用于在事务回滚或系统崩溃时，撤销这个转账操作。</li><li>例如，Undo log 中可能记录了对账户A余额增加100元和对账户B余额减少100元的撤销操作。</li></ul></li></ol><h4 id="具体语句是什么" tabindex="-1"><a class="header-anchor" href="#具体语句是什么"><span>具体语句是什么？</span></a></h4><p>在 Redo log 中记录的重做操作通常<strong>不是以 SQL 语句</strong>的形式呈现，而通常是数据库引擎内部的二进制格式</p><p>具体到上述示例中，Redo log 中可能记录了对账户A余额减少100元和对账户B余额增加100元的重做操作，但这些操作并不会以 SQL 语句的形式直接出现。相反，它们可能是一些类似于以下格式的二进制记录：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>[账户A的数据块标识符]：[减少100元的操作]
[账户B的数据块标识符]：[增加100元的操作]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>数据库引擎用于在系统发生故障后重新应用这些修改，从而确保数据库的一致性和持久性。</p><h3 id="为什么需要事务-why" tabindex="-1"><a class="header-anchor" href="#为什么需要事务-why"><span>为什么需要事务？（why)</span></a></h3><ul><li>保证数据的一致性和完整性</li></ul><h3 id="如何开启事务-how" tabindex="-1"><a class="header-anchor" href="#如何开启事务-how"><span>如何开启事务（how）</span></a></h3><p>在 MySQL 中，你可以使用以下 SQL 命令来开启事务：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令会开始一个新的事务，并将其标记为当前事务。一旦你开启了事务，你就可以执行一系列的 SQL 操作，这些操作将会被当作一个原子操作组合起来，要么全部执行成功，要么全部失败。</p><p>如果你想在 MySQL 中开启一个只读的事务，可以使用以下命令：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">READ</span> ONLY<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而如果你想开启一个读写的事务，则可以使用：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">READ</span> <span class="token keyword">WRITE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>无论是哪种类型的事务，一旦你完成了所有的数据库操作，并且你想要提交事务，你可以使用以下命令：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你想要取消事务并回滚到事务开始之前的状态，可以使用以下命令：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上就是在 MySQL 中开启、提交和取消事务的方法。 <strong>例子</strong> 假设我们有一个银行数据库，其中包含了账户信息，我们想要进行一系列的银行交易操作，确保这些操作要么全部成功，要么全部失败。我们可以使用事务来保证这一点。</p><p>首先，我们开启一个事务：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，我们执行一系列的 SQL 操作，比如从一个账户转账到另一个账户，并更新账户余额：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> account_id <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> account_id <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，我们检查一下余额是否足够，以确保转账不会导致负余额：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> balance <span class="token keyword">FROM</span> accounts <span class="token keyword">WHERE</span> account_id <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> balance <span class="token keyword">FROM</span> accounts <span class="token keyword">WHERE</span> account_id <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果余额足够，我们提交事务：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果出现任何问题，比如余额不足，我们可以取消事务并回滚到操作之前的状态：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过使用事务，我们可以确保所有的银行交易操作要么全部成功，要么全部失败，从而保证了数据的一致性和完整性。</p><h2 id="并发事务带来什么问题-why-but" tabindex="-1"><a class="header-anchor" href="#并发事务带来什么问题-why-but"><span>并发事务带来什么问题（why-but）</span></a></h2><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><h2 id="为什么要有事务的隔离级别-why" tabindex="-1"><a class="header-anchor" href="#为什么要有事务的隔离级别-why"><span>为什么要有事务的隔离级别？（why）</span></a></h2><h3 id="事务有哪些隔离级别-what" tabindex="-1"><a class="header-anchor" href="#事务有哪些隔离级别-what"><span>事务有哪些隔离级别（what？）</span></a></h3><ul><li>读未提交（Read-Uncommited）</li><li>读已提交（read-commited）</li><li>可重复读（repeatabl-read）【默认】</li><li>可串行化</li></ul><h3 id="事务的隔离级别是怎么实现的-how" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别是怎么实现的-how"><span>事务的隔离级别是怎么实现的(how)</span></a></h3><ul><li>锁+MVCC</li></ul><blockquote><p>锁和多版本并发控制（MVCC）是实现 MySQL 中隔离级别的两种关键机制。它们提供了不同的方法来处理并发访问数据库时可能出现的问题，并在不同的隔离级别下提供了不同的行为。下面分别介绍它们是如何实现隔离级别的：</p></blockquote><ol><li><p><strong>锁</strong>：</p><ul><li><p><strong>行级锁和表级锁</strong>：MySQL 支持行级锁和表级锁。<strong>行级锁允许多个事务同时访问同一表的不同行</strong>，从而提高了并发性。</p><ul><li>表级锁在整个表上进行锁定，会导致其他事务无法访问整个表，因此并发性较低。</li></ul></li><li><p><strong>共享锁和排他锁</strong>：共享锁（Shared Lock）允许多个事务同时读取同一资源，但阻止其他事务对资源进行写入操作。</p><ul><li>排他锁（Exclusive Lock）则只允许一个事务对资源进行读写操作，阻止其他事务读取或写入资源。</li></ul></li><li><p><strong>锁的粒度</strong>：MySQL 中的锁可以精确到行级别，也可以是更高级别的表级锁。</p><ul><li>行级锁可以提高并发性，但可能会导致锁定开销增加。表级锁相对粗粒度，可以降低锁定开销，但并发性较差。</li></ul></li></ul></li><li><p><strong>多版本并发控制（MVCC）</strong>：</p><ul><li><p>（what）MVCC 是一种更为先进的并发控制机制，它通过保存数据的多个版本来实现不同事务之间的隔离性。</p></li><li><p>（how）当事务开始时，MySQL 会为每个修改的行创建一个版本，并将其保存在 undo log 中。</p></li><li><p>其他事务在读取数据时会根据事务的可见性规则，选择合适的数据版本进行读取，从而实现隔离性。</p></li><li><p>在 MVCC 中，读取操作不会阻塞写入操作，也不会阻塞其他读取操作，因此可以提高并发性。同时，MVCC 也能够解决不可重复读和幻读等并发问题。</p></li><li><p>MySQL 使用 MVCC 来实现可重复读隔离级别。在可重复读隔离级别下，事务在执行期间看到的数据保持一致，</p></li><li><p>即使其他事务对数据进行了修改。这是通过使用快照读和间隙锁来实现的。</p></li></ul></li></ol><h3 id="快照读和间隙锁是什么-what" tabindex="-1"><a class="header-anchor" href="#快照读和间隙锁是什么-what"><span>快照读和间隙锁是什么（what）</span></a></h3><h3 id="innodb有哪几类行级锁-what" tabindex="-1"><a class="header-anchor" href="#innodb有哪几类行级锁-what"><span>InnoDB有哪几类行级锁（what）？</span></a></h3><pre><code>好的，让我们包含一个具体的账户表格，并演示两个事务对账户进行转账操作的情景。
</code></pre><p>假设我们有以下账户表格：</p><table><thead><tr><th>id</th><th>account_number</th><th>balance</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>1000.00</td></tr><tr><td>2</td><td>B</td><td>500.00</td></tr></tbody></table><p>现在，我们有两个事务，分别要对账户A进行转账操作：</p><p>事务1：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">WHERE</span> account_number <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>事务2：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> accounts <span class="token keyword">SET</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">50</span> <span class="token keyword">WHERE</span> account_number <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在这个例子中，事务1尝试向账户A转账100美元，而事务2尝试向账户A转账50美元。由于两个事务都涉及同一账户，因此需要对该账户的行进行加锁。</p></blockquote><blockquote><p>在事务1执行更新操作时，会对账户A的记录加上排他锁（Exclusive Lock），阻止其他事务对其进行读取或写入操作。这样，当事务2也尝试更新账户A的记录时，由于无法获取到排他锁，将会被阻塞，直到事务1完成或回滚后才能继续执行。</p></blockquote><p>通过行级锁的机制，我们确保了对同一账户的转账操作是串行执行的，从而避免了并发问题，保证了数据的一致性和完整性。</p><ol><li><p><strong>共享锁（Shared Lock）</strong>：</p><ul><li>共享锁也称为读锁，它允许多个事务同时读取同一行数据，但阻止其他事务对该行进行写入操作。</li><li>共享锁之间互不阻塞，多个事务可以同时持有共享锁。</li><li>当事务持有共享锁时，其他事务也可以获取共享锁，但无法获取排他锁。</li></ul></li><li><p><strong>排他锁（Exclusive Lock）</strong>：</p><ul><li>排他锁也称为写锁，它阻止其他事务对同一行数据进行读取或写入操作。</li><li>排他锁和其他任何锁都是互斥的，一个事务持有排他锁时，其他事务无法获取任何类型的锁。</li><li>当事务持有排他锁时，其他事务无法获取共享锁或排他锁。</li></ul></li><li><p><strong>意向锁（Intention Lock）</strong>：</p><ul><li>意向锁是为了提高并发性能而引入的一种辅助锁机制，用于<strong>表级锁定</strong>。</li><li>在事务获取行级锁之前，会先获取相应的意向锁，用于表示事务打算对表中的行进行何种类型的锁定。</li><li>意向锁有两种类型：意向共享锁（IS）和意向排他锁（IX），分别表示事务打算获取共享锁或排他锁。</li></ul></li><li><p><strong>记录锁（Record Lock）</strong>：</p><ul><li>记录锁是 InnoDB 存储引擎在行级锁定时使用的一种锁定机制，用于锁定<strong>单个行</strong>。</li><li>当事务获取到记录锁后，其他事务无法对该行进行<strong>相同类型</strong>的锁定，但可以对该行进行<strong>不同类型</strong>的锁定。</li><li>记录锁在事务提交或回滚后会自动释放。</li></ul></li><li><p><strong>间隙锁（Gap Lock）</strong>：</p><ul><li>间隙锁用于锁定两个<strong>索引记录</strong>之间的“间隙”，防止其他事务在这个间隙中插入新的记录。</li><li>间隙锁可以避免幻读的问题，在某些情况下也可以避免不可重复读问题。</li><li>InnoDB 存储引擎在可重复读隔离级别下会自动使用间隙锁。</li></ul></li></ol><p>好的，让我来为你举一个例子来说明意向锁、间隙锁和记录锁的作用。</p><p>假设我们有一个简单的学生信息数据库表格，包含学生的ID、姓名和年龄：</p><table><thead><tr><th>学生ID</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>20</td></tr><tr><td>2</td><td>小红</td><td>22</td></tr><tr><td>3</td><td>小华</td><td>21</td></tr><tr><td>4</td><td>小李</td><td>23</td></tr></tbody></table><p>现在有两个并发事务正在执行：</p><ol><li><strong>事务A</strong>：要向数据库中插入一个年龄为21岁的学生记录。</li><li><strong>事务B</strong>：要查询年龄在20岁到22岁之间的学生记录。</li></ol><p>下面是事务A和事务B执行时各种锁的作用：</p><table><thead><tr><th>事务</th><th>操作</th><th>锁类型</th><th>锁定行/间隙</th><th>说明</th></tr></thead><tbody><tr><td>事务A</td><td>开始</td><td></td><td></td><td></td></tr><tr><td>事务A</td><td>意向排他锁（Intent X）</td><td>意向排他锁</td><td></td><td>表示事务A打算在表上设置排他锁</td></tr><tr><td>事务A</td><td>间隙锁（Gap Lock）</td><td>间隙锁</td><td>学生ID为3</td><td>防止其他事务在年龄为21的记录前后插入新的记录</td></tr><tr><td>事务A</td><td>记录锁（Record Lock）</td><td>记录锁</td><td>学生ID为3</td><td>防止其他事务同时修改ID为3的学生记录</td></tr><tr><td>事务A</td><td>插入年龄为21的学生记录</td><td>排他锁</td><td>新记录</td><td>事务A向表中插入了一个年龄为21的学生记录，并持有排他锁</td></tr><tr><td>事务A</td><td>提交</td><td></td><td></td><td></td></tr><tr><td>事务B</td><td>开始</td><td></td><td></td><td></td></tr><tr><td>事务B</td><td>意向共享锁（Intent S）</td><td>意向共享锁</td><td></td><td>表示事务B打算在表上设置共享锁</td></tr><tr><td>事务B</td><td>间隙锁（Gap Lock）</td><td>间隙锁</td><td>学生ID为1</td><td>防止其他事务在年龄为20到22之间的记录前后插入新的记录</td></tr><tr><td>事务B</td><td>查询年龄在20岁到22岁之间的学生记录</td><td>共享锁</td><td>学生ID为1到学生ID为3之间</td><td>事务B查询了年龄在20岁到22岁之间的学生记录，并持有共享锁</td></tr><tr><td>事务B</td><td>提交</td><td></td><td></td><td></td></tr></tbody></table><p>在这个例子中，事务A使用了意向锁、间隙锁和记录锁来确保插入新记录的原子性和一致性，而事务B使用了意向锁和间隙锁来确保查询结果的一致性。通过合理使用这些锁，可以保证并发事务的安全执行，避免数据不一致的情况发生。想·</p><h2 id="如何控制并发事务-how" tabindex="-1"><a class="header-anchor" href="#如何控制并发事务-how"><span>如何控制并发事务？（how）</span></a></h2><ul><li>锁+mvcc</li><li></li></ul>`,93),d=[o];function i(p,r){return n(),a("div",null,d)}const h=s(t,[["render",i],["__file","mysql事务.html.vue"]]),g=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%85%E5%AE%8C%E5%B7%A5/mysql%E4%BA%8B%E5%8A%A1.html","title":"待定名称","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-05-05T00:00:00.000Z","category":["数据库"],"tag":["红","圆"],"star":true,"sticky":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"mysql的基础架构（一条sql语句在mysql中的执行流程）","slug":"mysql的基础架构-一条sql语句在mysql中的执行流程","link":"#mysql的基础架构-一条sql语句在mysql中的执行流程","children":[{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"mysql有哪两个存储引擎？都有事务吗（what）","slug":"mysql有哪两个存储引擎-都有事务吗-what","link":"#mysql有哪两个存储引擎-都有事务吗-what","children":[]},{"level":2,"title":"单个mysql事务","slug":"单个mysql事务","link":"#单个mysql事务","children":[{"level":3,"title":"什么是事务（what）","slug":"什么是事务-what","link":"#什么是事务-what","children":[]},{"level":3,"title":"事务特性ACID","slug":"事务特性acid","link":"#事务特性acid","children":[]},{"level":3,"title":"靠什么来保证mysql的特性的？（how）","slug":"靠什么来保证mysql的特性的-how","link":"#靠什么来保证mysql的特性的-how","children":[]},{"level":3,"title":"延伸：redoLog和undo log是什么（what）","slug":"延伸-redolog和undo-log是什么-what","link":"#延伸-redolog和undo-log是什么-what","children":[]},{"level":3,"title":"redo log和undo log举个例子：","slug":"redo-log和undo-log举个例子","link":"#redo-log和undo-log举个例子","children":[]},{"level":3,"title":"为什么需要事务？（why)","slug":"为什么需要事务-why","link":"#为什么需要事务-why","children":[]},{"level":3,"title":"如何开启事务（how）","slug":"如何开启事务-how","link":"#如何开启事务-how","children":[]}]},{"level":2,"title":"并发事务带来什么问题（why-but）","slug":"并发事务带来什么问题-why-but","link":"#并发事务带来什么问题-why-but","children":[]},{"level":2,"title":"为什么要有事务的隔离级别？（why）","slug":"为什么要有事务的隔离级别-why","link":"#为什么要有事务的隔离级别-why","children":[{"level":3,"title":"事务有哪些隔离级别（what？）","slug":"事务有哪些隔离级别-what","link":"#事务有哪些隔离级别-what","children":[]},{"level":3,"title":"事务的隔离级别是怎么实现的(how)","slug":"事务的隔离级别是怎么实现的-how","link":"#事务的隔离级别是怎么实现的-how","children":[]},{"level":3,"title":"快照读和间隙锁是什么（what）","slug":"快照读和间隙锁是什么-what","link":"#快照读和间隙锁是什么-what","children":[]},{"level":3,"title":"InnoDB有哪几类行级锁（what）？","slug":"innodb有哪几类行级锁-what","link":"#innodb有哪几类行级锁-what","children":[]}]},{"level":2,"title":"如何控制并发事务？（how）","slug":"如何控制并发事务-how","link":"#如何控制并发事务-how","children":[]}],"git":{"createdTime":1715147656000,"updatedTime":1726469543000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":16.05,"words":4815},"filePathRelative":"posts/数据库/待完工/mysql事务.md","localizedDate":"2024年5月5日"}');export{h as comp,g as data};
