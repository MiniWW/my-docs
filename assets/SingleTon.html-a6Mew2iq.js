import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,f as e}from"./app-D8tK2wE0.js";const t={},o=e(`<h1 id="创建型模式-单例模式" tabindex="-1"><a class="header-anchor" href="#创建型模式-单例模式"><span>创建型模式-单例模式</span></a></h1><h2 id="单例模式是什么-what" tabindex="-1"><a class="header-anchor" href="#单例模式是什么-what"><span>单例模式是什么（what）</span></a></h2><blockquote><p>单例模式是一种设计模式，保证一个类只有一个实例，提供一个全局访问点 通过单例模式，我们可以控制对象的创建过程，避免重复实例化相同的对象，节省系统资源（why）</p></blockquote><h2 id="为什么要用单例模式-why" tabindex="-1"><a class="header-anchor" href="#为什么要用单例模式-why"><span>为什么要用单例模式（why）</span></a></h2><blockquote><p>通过单例模式，我们可以控制对象创建的过程，避免重复实例化相同的对象，节省系统的资源</p></blockquote><h2 id="怎么用单例模式-how" tabindex="-1"><a class="header-anchor" href="#怎么用单例模式-how"><span>怎么用单例模式（how）</span></a></h2><blockquote><p>单例模式的角色和组成是什么？</p><ol><li>私有构造函数</li><li>私有静态成员变量</li><li>共有静态提供实例的方法</li></ol></blockquote><blockquote><p>创建单例模式有两种方式</p><ol><li>饿汉式：what：在类加载时就进行创建了实例；why：简单直接；but：浪费内存资源</li><li>懒汉式：what：在需要时才创建实例，延迟加载，why：节省资源；but：存在线程安全的问题</li></ol></blockquote><h2 id="单例模式实例代码" tabindex="-1"><a class="header-anchor" href="#单例模式实例代码"><span>单例模式实例代码</span></a></h2><h3 id="静态内部类版本-饿汉式" tabindex="-1"><a class="header-anchor" href="#静态内部类版本-饿汉式"><span>静态内部类版本-饿汉式</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span>  singleTon<span class="token punctuation">{</span>
<span class="token comment">//    私有的构造方法</span>
    <span class="token keyword">private</span>  <span class="token function">singleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//    私有的静态内部类</span>
    <span class="token keyword">private</span>  <span class="token keyword">class</span> singleTonHandler<span class="token punctuation">{</span>
    <span class="token comment">//注意这里写new</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> singleTon instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">singleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//全局访问点</span>
    <span class="token keyword">public</span> singleTon <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//不是直接写instance</span>
        <span class="token keyword">return</span>  singleTonHandler<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//    防止反序列化破解单例模式</span>
<span class="token comment">//注意这里的返回值是Object，</span>
<span class="token comment">//注意这里是private</span>
    <span class="token keyword">private</span>  <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span>  singleTonHandler<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>为什么序列化和反序列化会破坏单例模式（why） 因为一个单例类被序列化之后，再反序列化，会在创建一个对象，就破坏了单例的初衷</p><ol><li><strong>因为反序列化会绕过类的构造函数，直接从序列化数据中恢复对象</strong></li></ol><p>如何解决（how） 2. 在单例类中实现readResolve（）方法，当进行反序列化时，，会调用这个方法，直接返回已经存在的单例，而不是创建新对象</p></blockquote><blockquote><p>双检锁版本：</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> singleTon<span class="token punctuation">{</span>
<span class="token comment">//    私有的构造方法</span>
   <span class="token keyword">private</span>  <span class="token function">singleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//        防止反射破解单例模式</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//    静态私有成员变量</span>
   <span class="token keyword">private</span>  <span class="token keyword">static</span>  <span class="token keyword">volatile</span> singleTon instance<span class="token punctuation">;</span>

<span class="token comment">//    全局访问点</span>
   <span class="token keyword">public</span>  <span class="token keyword">static</span>  singleTon <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>singleTon<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">singleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),p=[o];function i(c,l){return s(),a("div",null,p)}const d=n(t,[["render",i],["__file","SingleTon.html.vue"]]),k=JSON.parse('{"path":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/SingleTon.html","title":"创建型模式-单例模式","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-05-05T00:00:00.000Z","category":["设计模式"],"tag":["红","圆"],"star":true,"sticky":true,"description":"创建型模式-单例模式 单例模式是什么（what） 单例模式是一种设计模式，保证一个类只有一个实例，提供一个全局访问点 通过单例模式，我们可以控制对象的创建过程，避免重复实例化相同的对象，节省系统资源（why） 为什么要用单例模式（why） 通过单例模式，我们可以控制对象创建的过程，避免重复实例化相同的对象，节省系统的资源 怎么用单例模式（how） 单例...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/SingleTon.html"}],["meta",{"property":"og:site_name","content":"主页"}],["meta",{"property":"og:title","content":"创建型模式-单例模式"}],["meta",{"property":"og:description","content":"创建型模式-单例模式 单例模式是什么（what） 单例模式是一种设计模式，保证一个类只有一个实例，提供一个全局访问点 通过单例模式，我们可以控制对象的创建过程，避免重复实例化相同的对象，节省系统资源（why） 为什么要用单例模式（why） 通过单例模式，我们可以控制对象创建的过程，避免重复实例化相同的对象，节省系统的资源 怎么用单例模式（how） 单例..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-29T08:12:08.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"创建型模式-单例模式"}],["meta",{"property":"article:author","content":"MiniW"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:tag","content":"圆"}],["meta",{"property":"article:published_time","content":"2024-05-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-29T08:12:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"创建型模式-单例模式\\",\\"image\\":[\\"https://mister-hope.github.io/my-docs/assets/images/cover2.jpg\\"],\\"datePublished\\":\\"2024-05-05T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-29T08:12:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MiniW\\"}]}"]]},"headers":[{"level":2,"title":"单例模式是什么（what）","slug":"单例模式是什么-what","link":"#单例模式是什么-what","children":[]},{"level":2,"title":"为什么要用单例模式（why）","slug":"为什么要用单例模式-why","link":"#为什么要用单例模式-why","children":[]},{"level":2,"title":"怎么用单例模式（how）","slug":"怎么用单例模式-how","link":"#怎么用单例模式-how","children":[]},{"level":2,"title":"单例模式实例代码","slug":"单例模式实例代码","link":"#单例模式实例代码","children":[{"level":3,"title":"静态内部类版本-饿汉式","slug":"静态内部类版本-饿汉式","link":"#静态内部类版本-饿汉式","children":[]}]}],"git":{"createdTime":1714975363000,"updatedTime":1727597528000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":7}]},"readingTime":{"minutes":1.99,"words":596},"filePathRelative":"posts/设计模式/创建型模式/SingleTon.md","localizedDate":"2024年5月5日","excerpt":"\\n<h2>单例模式是什么（what）</h2>\\n<blockquote>\\n<p>单例模式是一种设计模式，保证一个类只有一个实例，提供一个全局访问点\\n通过单例模式，我们可以控制对象的创建过程，避免重复实例化相同的对象，节省系统资源（why）</p>\\n</blockquote>\\n<h2>为什么要用单例模式（why）</h2>\\n<blockquote>\\n<p>通过单例模式，我们可以控制对象创建的过程，避免重复实例化相同的对象，节省系统的资源</p>\\n</blockquote>\\n<h2>怎么用单例模式（how）</h2>\\n<blockquote>\\n<p>单例模式的角色和组成是什么？</p>\\n<ol>\\n<li>私有构造函数</li>\\n<li>私有静态成员变量</li>\\n<li>共有静态提供实例的方法</li>\\n</ol>\\n</blockquote>","autoDesc":true}');export{d as comp,k as data};
