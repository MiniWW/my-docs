import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as t,f as o}from"./app-B5wQ218V.js";const s="/my-docs/assets/img-oENUmgg_.png",n="/my-docs/assets/img_2-DD_Z74C5.png",r="/my-docs/assets/img_1-p1Sod-sl.png",l={},d=o('<h1 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化"><span>Redis持久化</span></a></h1><blockquote><p>有RDB和AOF两种方式</p><ul><li><p>RDB是一个快照文件，它可以在指定的之间间隔内，把内存中的数据集写到磁盘，也就是保留某个时间点的数据集，</p><ul><li>redis实例宕机恢复数据的时候，用RDB的快照文件恢复是比较快的，因为它是个二进制文件，体积比较小</li></ul></li><li><p>AOF的是个追加文件，当redis操作<strong>写命令</strong>的时候，都会存储这个AOF日志文件中，</p><ul><li>（当redis实例宕机恢复数据的时候），<strong>重做这些命令</strong>就能恢复数据，所以用它恢复会比较慢一些，但是用它丢失的风险会小很多，<strong>所以适用于对数据安全性较高的场景</strong>：比如购物车、订单等关键业务</li><li>因为RDB可能会丢失某一时间间隔的数据，如果某个时间间隔变动的数据很多，那么那个时间间隔的数据变动情况可能都丢失了</li><li>AOF丢失数据的风险会小很多，因为它可以设置AOF追加一个写命令就刷盘的策略 <ul><li>AOF丢失数据的风险在:Redis执行一个写命令，还没来得及写入AOF，就宕机了，所以可能丢失那一条命令</li></ul></li></ul></li></ul><p>他们的原理呢：</p><ul><li>redis要形成快照文件的时候，会从主线程Fork一个子进程来生成快照。在子进程会读取redis内存中的数据集，把数据集写入到一个【临时文件】、写入成功之后，再替换原来的RDB文件，用二进制的形式压缩 <ul><li>如果在生成快照的过程中，如果有redis写操作来修改redis里的数据，就采取“copy on wirite”写时复制的策略，复制一个没有修改之前的数据副本，把数据副本保存到RDB文件中，主线程继续对原来数据进行修改，这样（主线程和子进程）互不影响</li></ul></li></ul></blockquote><p><img src="'+s+'" alt="img.png" loading="lazy"><img src="'+n+'" alt="img_2.png" loading="lazy"></p><blockquote><ul><li><p>AOF的背后原理：</p></li><li><p>AOF则是将所有redis写命令追加到AOF文件中，再采取一些刷盘策略（每秒刷盘，每修改一次数据就同步一次，或者不同步）持久化到磁盘中，</p><p><strong>缓冲区机制</strong>：</p><ul><li>写操作首先会被追加到 AOF 缓冲区中，而不是直接写入磁盘。AOF 缓冲区是 Redis 的内存区域，用于暂存需要写入到 AOF 文件中的命令。</li><li>之后，Redis 会根据配置中的 <code>fsync</code> 策略，将缓冲区中的数据写入磁盘，确保数据的持久化。</li></ul><p><strong><code>fsync</code> 策略</strong>：</p><ul><li>Redis 提供了三种 刷盘策略 策略，用来控制 AOF 缓冲区的数据写入磁盘的频率： <ul><li><strong><code>always</code></strong>：每次有新命令写入 AOF 缓冲区时，立即调用 <code>fsync</code>，将数据写入磁盘。这种方式最安全，但性能较低，因为每个写操作都会触发磁盘写入。</li><li><strong><code>everysec</code></strong>：每秒执行一次 <code>fsync</code>，在 Redis 服务器的主线程之外的后台线程执行。大部分情况下，这种方式是性能与安全性的折中方案，可能会丢失最近一秒的数据。</li><li><strong><code>no</code></strong>：不主动调用 <code>fsync</code>，由操作系统决定何时将数据从缓冲区写入磁盘。这种方式性能最好，但存在数据丢失的风险。</li></ul></li></ul></li></ul><p><strong>AOF和RDB不同的一点还有：</strong></p><ul><li>如果当AOF文件过大，那么用AOF恢复数据时耗时太久，就要对它进行压缩【也就是AOF重写机制】，也是fork一个子进程来执行：：也就是先读取当前redis数据库中的所有键值对，并逐一把键值对转换成一条命令，也就是把对应键值对更新到最新的一条命令，（之前的历史版本忽略），再把这些命令搬运到新的AOF文件中</li></ul></blockquote><figure><img src="'+r+'" alt="img_1.png" tabindex="0" loading="lazy"><figcaption>img_1.png</figcaption></figure>',5),c=[d];function p(a,g){return i(),t("div",null,c)}const R=e(l,[["render",p],["__file","redis持久化.html.vue"]]),_=JSON.parse('{"path":"/posts/Redis/redis%E6%8C%81%E4%B9%85%E5%8C%96.html","title":"Redis持久化","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-09T00:00:00.000Z","category":["Redis"],"tag":["红","小","圆"],"description":"Redis持久化 有RDB和AOF两种方式 RDB是一个快照文件，它可以在指定的之间间隔内，把内存中的数据集写到磁盘，也就是保留某个时间点的数据集， redis实例宕机恢复数据的时候，用RDB的快照文件恢复是比较快的，因为它是个二进制文件，体积比较小 AOF的是个追加文件，当redis操作写命令的时候，都会存储这个AOF日志文件中， （当redis实例...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/posts/Redis/redis%E6%8C%81%E4%B9%85%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"主页"}],["meta",{"property":"og:title","content":"Redis持久化"}],["meta",{"property":"og:description","content":"Redis持久化 有RDB和AOF两种方式 RDB是一个快照文件，它可以在指定的之间间隔内，把内存中的数据集写到磁盘，也就是保留某个时间点的数据集， redis实例宕机恢复数据的时候，用RDB的快照文件恢复是比较快的，因为它是个二进制文件，体积比较小 AOF的是个追加文件，当redis操作写命令的时候，都会存储这个AOF日志文件中， （当redis实例..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-16T03:01:38.000Z"}],["meta",{"property":"article:author","content":"MiniW"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:tag","content":"小"}],["meta",{"property":"article:tag","content":"圆"}],["meta",{"property":"article:published_time","content":"2022-01-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-16T03:01:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis持久化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-09T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-16T03:01:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MiniW\\"}]}"]]},"headers":[],"git":{"createdTime":1726455698000,"updatedTime":1726455698000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":3.35,"words":1005},"filePathRelative":"posts/Redis/redis持久化.md","localizedDate":"2022年1月9日","excerpt":"\\n<blockquote>\\n<p>有RDB和AOF两种方式</p>\\n<ul>\\n<li>\\n<p>RDB是一个快照文件，它可以在指定的之间间隔内，把内存中的数据集写到磁盘，也就是保留某个时间点的数据集，</p>\\n<ul>\\n<li>redis实例宕机恢复数据的时候，用RDB的快照文件恢复是比较快的，因为它是个二进制文件，体积比较小</li>\\n</ul>\\n</li>\\n<li>\\n<p>AOF的是个追加文件，当redis操作<strong>写命令</strong>的时候，都会存储这个AOF日志文件中，</p>\\n<ul>\\n<li>（当redis实例宕机恢复数据的时候），<strong>重做这些命令</strong>就能恢复数据，所以用它恢复会比较慢一些，但是用它丢失的风险会小很多，<strong>所以适用于对数据安全性较高的场景</strong>：比如购物车、订单等关键业务</li>\\n<li>因为RDB可能会丢失某一时间间隔的数据，如果某个时间间隔变动的数据很多，那么那个时间间隔的数据变动情况可能都丢失了</li>\\n<li>AOF丢失数据的风险会小很多，因为它可以设置AOF追加一个写命令就刷盘的策略\\n<ul>\\n<li>AOF丢失数据的风险在:Redis执行一个写命令，还没来得及写入AOF，就宕机了，所以可能丢失那一条命令</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<p>他们的原理呢：</p>\\n<ul>\\n<li>redis要形成快照文件的时候，会从主线程Fork一个子进程来生成快照。在子进程会读取redis内存中的数据集，把数据集写入到一个【临时文件】、写入成功之后，再替换原来的RDB文件，用二进制的形式压缩\\n<ul>\\n<li>如果在生成快照的过程中，如果有redis写操作来修改redis里的数据，就采取“copy on wirite”写时复制的策略，复制一个没有修改之前的数据副本，把数据副本保存到RDB文件中，主线程继续对原来数据进行修改，这样（主线程和子进程）互不影响</li>\\n</ul>\\n</li>\\n</ul>\\n</blockquote>","autoDesc":true}');export{R as comp,_ as data};
