import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as e,f as a}from"./app-D8tK2wE0.js";const i="/my-docs/assets/img-D0N-S8x-.png",s={},r=a('<h1 id="待定名称" tabindex="-1"><a class="header-anchor" href="#待定名称"><span>待定名称</span></a></h1><h2 id="总图" tabindex="-1"><a class="header-anchor" href="#总图"><span>总图</span></a></h2><h2 id="什么是元组-码-键-候选码-主码-主键-外码-主属性-非主属性" tabindex="-1"><a class="header-anchor" href="#什么是元组-码-键-候选码-主码-主键-外码-主属性-非主属性"><span>什么是元组, 码（键）, 候选码, 主码（主键）, 外码, 主属性, 非主属性？</span></a></h2><ul><li>元组:表（关系是一张表）中的一行数据</li><li>码（键）：可以唯一标识元组合的一个属性/多个属性组合</li><li>候选码：可能成为主码（键）的码，它可以唯一标识元组但最后不一定成为主码</li><li>主码：可以唯一标识元组的码，从候选码中选出来的，例如id</li><li>外码：是当前这张表中的一个属性，同时它关联另一张表的主码</li><li>主属性：构成主码的属性（如果主码有2个属性的话，主属性就有2个）</li><li>非主：一个元组的属性中，除了主属性之外的属性</li></ul><h2 id="什么是数据库范式-what" tabindex="-1"><a class="header-anchor" href="#什么是数据库范式-what"><span>什么是数据库范式（what）</span></a></h2><p>数据库范式是一组规则，来约束数据库的表结构</p><h3 id="为什么需要数据库范式-why" tabindex="-1"><a class="header-anchor" href="#为什么需要数据库范式-why"><span>为什么需要数据库范式（why）</span></a></h3><p>减少数据冗余，节省存储空间</p><h3 id="有哪些数据库范式-如何区分-what" tabindex="-1"><a class="header-anchor" href="#有哪些数据库范式-如何区分-what"><span>有哪些数据库范式，如何区分？（what）</span></a></h3><ul><li>第一范式（默认）：<strong>属性不可再分</strong>。基本关系数据库创建的每一张表都满足，</li><li>第二范式要求<strong>非主属性对任何候选键都是完全依赖的</strong>，不出现部分依赖的情况</li></ul><blockquote><p>考虑一个订单表，其中包含订单号、产品编号和产品描述。如果产品描述只依赖于产品编号而不依赖于订单号， 那么该表就不符合第二范式，因为产品描述只依赖于候选键的一部分。 为了符合第二范式，可以将产品描述与产品编号分离出来， 建立一个独立的产品表，使得产品描述完全依赖于产品编号. <img src="'+i+`" alt="img.png" loading="lazy"> -- 第三范式：要求<strong>非主属性不能对候选码产生传递依赖</strong>，也就是说非主属性直接依赖于候选键，而不是依赖于其他非主属性</p></blockquote><blockquote><p>例如，在一个订单表中，除了订单号和产品编号之外还有客户姓名和客户地址。如果客户地址依赖于客户姓名而不是订单号，则存在传递依赖。 为了符合第三范式，应该将客户姓名和客户地址分离出来，建立一个独立的客户表，使得客户地址直接依赖于候选键（可能是客户编号），而不是依赖于客户姓名。</p></blockquote><blockquote><p>比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。 该如何修改？(how)</p><p><strong>直接分解关系</strong>：</p></blockquote><p>关系R(学号, 姓名, 系名, 系主任)，存在非主属性系主任对于学号的传递函数依赖，因此不符合第三范式（3NF）的要求。</p><p>可以将关系R拆分为两个关系：</p><ol><li>学生关系（学号, 姓名, 系名）：这个关系包含了学生的学号、姓名以及所属系名。</li><li>系信息关系（系名, 系主任）：这个关系包含了系名和该系的系主任。</li></ol><p>这样，每个关系都符合第三范式的要求，不存在传递依赖。学生关系中，系名直接关联到系信息关系的系名，而不再通过系主任产生传递依赖。系信息关系中，系主任直接关联到系名，也不存在传递依赖。</p><p>修改后的关系如下：</p><pre><code>1. 学生关系：
</code></pre><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>计算机系</td></tr><tr><td>2</td><td>李四</td><td>数学系</td></tr><tr><td>3</td><td>王五</td><td>物理系</td></tr></tbody></table><pre><code>1. 系信息关系：
</code></pre><table><thead><tr><th>系名</th><th>系主任</th></tr></thead><tbody><tr><td>计算机系</td><td>王老师</td></tr><tr><td>数学系</td><td>张老师</td></tr><tr><td>物理系</td><td>李老师</td></tr></tbody></table><p>分别解决什么问题？</p><ul><li><strong>一：属性不可再分</strong></li><li><strong>二：进一步消除数据冗余</strong></li><li><strong>三：更近一步消除数据冗余，保证数据独立性和一致性</strong></li></ul><h4 id="bcnf" tabindex="-1"><a class="header-anchor" href="#bcnf"><span>BCNF</span></a></h4><ul><li><p>BCNF是第三范式（3NF）的一个更严格的形式</p></li><li><p>对于每一个函数依赖，左边的属性集必须包含这个表的所有候选键</p></li><li><p>考虑一个关系模式 <code>R(教师, 课程, 课程时间)</code>，其中教师和课程的组合可以唯一标识一条记录，所以 <code>(教师, 课程)</code> 是主键。</p><p>假设存在如下依赖关系：</p><ul><li>教师 → 课程时间</li></ul><p>这个依赖关系表明，每个教师只能在特定时间教授课程。</p><p>按照第三范式，该表是符合要求的，因为：</p><ul><li>没有部分依赖，课程时间是完全依赖于候选键 <code>(教师, 课程)</code>。</li><li>也不存在传递依赖，所有属性都直接依赖于候选键。</li></ul><p>但该表不符合BCNF，因为：</p><ul><li><p>教师 → 课程时间 违反了BCNF的定义。这里教师并不是表的<strong>超键</strong>，但它却决定了课程时间。</p></li><li><p>如何将这个关系模式转换为符合BCNF？</p><p>我们可以将关系模式拆分为两个关系**（分表）**：</p><ol><li><code>R1(教师, 课程时间)</code>：教师与课程时间的关系。</li><li><code>R2(教师, 课程)</code>：教师与课程的关系。</li></ol><p>这样，每个关系都符合BCNF，因为在 <code>R1</code> 中，教师是超键；在 <code>R2</code> 中，教师和课程的组合是超键。</p></li></ul></li><li><p>超键和候选键的关系：</p><ul><li><p><strong>主键</strong>：主键（Primary Key）是从超键中选择的一个，它在表中唯一标识每一行，并且通常选择最小的属性组合（即没有多余属性）。</p><p><strong>候选键</strong>：候选键（Candidate Key）是指那些有可能成为主键的超键。如果一个超键是最小的（无法去掉任何一个属性而仍然保持唯一性），它就是候选键。</p></li></ul></li></ul><h2 id="第几范式能消除数据冗余" tabindex="-1"><a class="header-anchor" href="#第几范式能消除数据冗余"><span>第几范式能消除数据冗余？</span></a></h2><ul><li>第三范式</li><li><h2 id="why" tabindex="-1"><a class="header-anchor" href="#why"><span>why？</span></a></h2></li></ul><h2 id="数据库几大范式分别解决了什么问题" tabindex="-1"><a class="header-anchor" href="#数据库几大范式分别解决了什么问题"><span>数据库几大范式分别解决了什么问题？</span></a></h2><ul><li><strong>一</strong>：属性不可再分</li><li><strong>二</strong>：进一步消除部分依赖，确保每个非主属性完全依赖于整个主键</li><li><strong>三</strong>：消除传递依赖，保证非主属性只直接依赖于主键，而不依赖于其他非主属性</li></ul>`,30),d=[r];function o(n,h){return l(),e("div",null,d)}const g=t(s,[["render",o],["__file","mysql基础.html.vue"]]),u=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%85%E5%AE%8C%E5%B7%A5/mysql%E5%9F%BA%E7%A1%80.html","title":"待定名称","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-05-05T00:00:00.000Z","category":["数据库"],"tag":["红","圆"],"star":true,"sticky":true,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"总图","slug":"总图","link":"#总图","children":[]},{"level":2,"title":"什么是元组, 码（键）, 候选码, 主码（主键）, 外码, 主属性, 非主属性？","slug":"什么是元组-码-键-候选码-主码-主键-外码-主属性-非主属性","link":"#什么是元组-码-键-候选码-主码-主键-外码-主属性-非主属性","children":[]},{"level":2,"title":"什么是数据库范式（what）","slug":"什么是数据库范式-what","link":"#什么是数据库范式-what","children":[{"level":3,"title":"为什么需要数据库范式（why）","slug":"为什么需要数据库范式-why","link":"#为什么需要数据库范式-why","children":[]},{"level":3,"title":"有哪些数据库范式，如何区分？（what）","slug":"有哪些数据库范式-如何区分-what","link":"#有哪些数据库范式-如何区分-what","children":[]}]},{"level":2,"title":"第几范式能消除数据冗余？","slug":"第几范式能消除数据冗余","link":"#第几范式能消除数据冗余","children":[]},{"level":2,"title":"数据库几大范式分别解决了什么问题？","slug":"数据库几大范式分别解决了什么问题","link":"#数据库几大范式分别解决了什么问题","children":[]}],"git":{"createdTime":1726468856000,"updatedTime":1726472191000,"contributors":[{"name":"MiniWH","email":"122033963+MiniWwww@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":5.23,"words":1570},"filePathRelative":"posts/数据库/待完工/mysql基础.md","localizedDate":"2024年5月5日"}');export{g as comp,u as data};
